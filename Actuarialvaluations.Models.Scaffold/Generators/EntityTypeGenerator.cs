namespace Actuarialvaluations.Models.Scaffold.Generators
{
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using Microsoft.EntityFrameworkCore.Design;
  using Microsoft.EntityFrameworkCore.Metadata;
  using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

  /// <summary>
  /// The EntityTypeGenerator class
  /// </summary>
  public class EntityTypeGenerator : CSharpEntityTypeGenerator
  {
    /// <summary>
    /// The metadata class name
    /// </summary>
    private const string MetadataClassName = "Metadata";

    /// <summary>
    /// The C# helper
    /// </summary>
    private readonly ICSharpHelper cSharpHelper;

    /// <summary>
    /// Initializes a new instance of the <see cref="EntityTypeGenerator"/> class.
    /// </summary>
    /// <param name="cSharpHelper">The C# helper</param>
    public EntityTypeGenerator(ICSharpHelper cSharpHelper)
      : base(cSharpHelper)
    {
      this.cSharpHelper = cSharpHelper;
    }

    /// <summary>
    /// Write the code
    /// </summary>
    /// <param name="entityType">The entity type</param>
    /// <param name="namespace">The namespace</param>
    /// <param name="useDataAnnotations">A value indicating whether to use data annotations</param>
    /// <returns>The code</returns>
    public override string WriteCode(IEntityType entityType, string @namespace, bool useDataAnnotations)
    {
      @namespace = @namespace.Replace("Models.Models", "Models");
      System.Console.WriteLine($"Generating {entityType.Name}");

      List<string> code = base.WriteCode(entityType, @namespace, useDataAnnotations).Split(new string[] { Environment.NewLine }, StringSplitOptions.None).ToList();

      this.CreateExtension(entityType, @namespace);
      this.MarkAutogenerated(code);
      this.AddBlankLinesBetweenProperties(code);
      this.RenameConflictingProperties(entityType.Name, code);

      return string.Join(Environment.NewLine, code);
    }

    /// <summary>
    /// Mark the output file as auto-generated
    /// </summary>
    /// <param name="code">The code</param>
    private void MarkAutogenerated(List<string> code)
    {
      code.InsertRange(
        0,
        new List<string>
        {
            $"//------------------------------------------------------------------------------",
            $"// <auto-generated>",
            $"//     This code was auto-generated.",
            $"//",
            $"//     Changes to this file may cause incorrect behavior and will be lost if",
            $"//     the code is regenerated.",
            $"// </auto-generated>",
            $"//------------------------------------------------------------------------------",
            $"",
        });
    }

    /// <summary>
    /// Create the extension class for the supplied entity
    /// </summary>
    /// <param name="entityType">The entity type</param>
    /// <param name="namespace">The namespace</param>
    private void CreateExtension(IEntityType entityType, string @namespace)
    {
      List<string> code = new List<string>
      {
        $"namespace {@namespace}",
        $"{{",
        $"  using System;",
        $"  using System.ComponentModel;",
        $"  using System.ComponentModel.DataAnnotations;",
        $"",
        $"  /// <summary>",
        $"  /// The model for the {entityType.Name} entity",
        $"  /// </summary>",
        $"  public partial class {entityType.Name}",
        $"  {{",
        $"  }}",
        $"}}"
      };

      DBScaffolder.ExtensionFiles.Add(
        new ScaffoldFile()
        {
          FileName = $"{entityType.Name}.Extension.cs",
          FileContents = string.Join(Environment.NewLine, code)
        });
    }

    /// <summary>
    /// Adds a blank line between properties in the main entity class
    /// </summary>
    /// <param name="code">Lines of code</param>
    private void AddBlankLinesBetweenProperties(List<string> code)
    {
      // This would be a lot easier if we had access to the _sb variable and could override GeneratePropertyDataAnnotations
      // So this just checks for { get; set; } and adds an empty line afterwards...
      bool foundFirstProperty = false;

      for (var i = code.Count - 1; i >= 0; i--)
      {
        if (code[i].EndsWith("{ get; set; }", StringComparison.CurrentCulture))
        {
          if (foundFirstProperty)
          {
            code.Insert(i + 1, string.Empty);
          }
          else
          {
            foundFirstProperty = true;
          }
        }
      }
    }

    /// <summary>
    /// Renames conflicting properties where the column name is the same as the class name.
    /// The base generator adds a 1 to the property name which looks fugly, so this will change it from TransactionType1 -> TransactionTypeName
    /// </summary>
    /// <param name="entityName">The name of the entity</param>
    /// <param name="code">Lines of code</param>
    private void RenameConflictingProperties(string entityName, List<string> code)
    {
      // rename ugly "Name1" properties
      GeneratorHelpers.ReplaceMember(
        code,
        "string",
        $"{entityName}1",
        $"{entityName}Name");
    }
  }
}
